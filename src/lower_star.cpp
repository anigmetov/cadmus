#include <vector>

#include <diy/grid.hpp>

#include "logger.h"
#include "filtration.h"
#include "profile.h"
#include "coh_block.h"

namespace cadmus {

// this function is auto-generated by scripts/freudenthal_cube.py
    template<size_t DD>
    std::vector<std::vector<std::vector<Int>>> fr_displacements(size_t dim)
    {
        size_t cube_dim = DD;

        switch(cube_dim) {
        case 1 :
            switch(dim) {
            case 0 :
                return {
                        {{0}}};
                break;
            case 1 :
                return {
                        {{0}, {1}}};
                break;
            }
            break;
        case 2 :
            switch(dim) {
            case 0 :
                return {
                        {{0, 0}}};
                break;
            case 1 :
                return {
                        {{0, 0}, {0, 1}},
                        {{0, 0}, {1, 1}},
                        {{0, 0}, {1, 0}}};
                break;
            case 2 :
                return {
                        {{0, 0}, {1, 0}, {1, 1}},
                        {{0, 0}, {0, 1}, {1, 1}}};
                break;
            }
            break;
        case 3 :
            switch(dim) {
            case 0 :
                return {
                        {{0, 0, 0}}};
                break;
            case 1 :
                return {
                        {{0, 0, 0}, {0, 1, 0}},
                        {{0, 0, 0}, {1, 1, 0}},
                        {{0, 0, 0}, {0, 1, 1}},
                        {{0, 0, 0}, {1, 1, 1}},
                        {{0, 0, 0}, {0, 0, 1}},
                        {{0, 0, 0}, {1, 0, 0}},
                        {{0, 0, 0}, {1, 0, 1}}};
                break;
            case 2 :
                return {
                        {{0, 0, 0}, {0, 0, 1}, {0, 1, 1}},
                        {{0, 0, 0}, {0, 0, 1}, {1, 0, 1}},
                        {{0, 0, 0}, {1, 0, 0}, {1, 0, 1}},
                        {{0, 0, 0}, {1, 0, 0}, {1, 1, 1}},
                        {{0, 0, 0}, {0, 1, 0}, {1, 1, 0}},
                        {{0, 0, 0}, {1, 0, 1}, {1, 1, 1}},
                        {{0, 0, 0}, {0, 1, 1}, {1, 1, 1}},
                        {{0, 0, 0}, {0, 1, 0}, {0, 1, 1}},
                        {{0, 0, 0}, {0, 0, 1}, {1, 1, 1}},
                        {{0, 0, 0}, {1, 0, 0}, {1, 1, 0}},
                        {{0, 0, 0}, {0, 1, 0}, {1, 1, 1}},
                        {{0, 0, 0}, {1, 1, 0}, {1, 1, 1}}};
                break;
            case 3 :
                return {
                        {{0, 0, 0}, {0, 0, 1}, {0, 1, 1}, {1, 1, 1}},
                        {{0, 0, 0}, {1, 0, 0}, {1, 0, 1}, {1, 1, 1}},
                        {{0, 0, 0}, {0, 1, 0}, {1, 1, 0}, {1, 1, 1}},
                        {{0, 0, 0}, {0, 0, 1}, {1, 0, 1}, {1, 1, 1}},
                        {{0, 0, 0}, {1, 0, 0}, {1, 1, 0}, {1, 1, 1}},
                        {{0, 0, 0}, {0, 1, 0}, {0, 1, 1}, {1, 1, 1}}};
                break;
            }
            break;
        }

        throw std::runtime_error("Unknown dimensions");
    }

    Int get_n_cubes_in_dimension(dim_type d)
    {
        if (d < 0 or d > CADMUS_DIM)
            throw std::runtime_error("bad dimension argument to get_n_cubes_in_dimension");

        // we have CADMUS_DIM directions,
        // a d-dimensional face is a subset of cardinality d
        Int result = 1;

        for(int k = CADMUS_DIM; k > CADMUS_DIM - d; --k)
            result *= k;

        for(int k = 1; k <= d; ++k)
            result /= k;

        return result;
    }

    VertexVecVec get_fr_displacements(size_t d)
    {
        VertexVecVec result;

        for(auto&& disps: fr_displacements<CADMUS_DIM>(d)) {
            result.emplace_back();
            for(auto&& disp: disps) {
                Vertex p;
                assert(disp.size() == p.size());
                for(size_t k = 0; k < disp.size(); ++k)
                    p[k] = disp[k];
                result.back().push_back(p);
            }
        }

        return result;
    }

    SimplicialFiltration CohBlock::get_freudenthal_filtration(dim_type top_d)
    {
        CALI_CXX_MARK_FUNCTION;
        auto logger = spd::get("console");
        // calculate total number of cells to allocate memory once
        size_t total_size = 0;
        for(dim_type d = 0; d <= top_d; ++d) {
            total_size += get_fr_displacements(d).size() * fab_.size();
        }

        simplices.reserve(total_size);

        for(dim_type d = 0; d <= top_d; ++d) {
            add_freudenthal_simplices(d);
            if (logger) logger->debug("CohBlock::get_freudenthal_filtration, d={}, simplices = {}, last simplex = {}", d, simplices.size(), simplices.back());
        }

        return SimplicialFiltration(std::move(simplices));
    }

    bool CohBlock::is_union(const Vertex& v_local) const
    {
        if (wrap_) {
            for(dim_type d = 0; d < CADMUS_DIM; ++d)
                if (v_local[d] == 0 or v_local[d] == fab_.shape()[d] - 1)
                    return true;
        } else {
            // TODO: wrap_ as vector for each dimension
            for(dim_type d = 0; d < CADMUS_DIM; ++d) {
                if (v_local[d] == 0 and core.min[d] > 0)
                    return true;
                if (v_local[d] == fab_.shape()[d] - 1 and core.max[d] < global_domain_.shape()[d] - 1)
                    return true;
            }
        }
        return false;
    }

    void CohBlock::add_freudenthal_simplices(dim_type d)
    {
        auto disps = get_fr_displacements(d);

        for(Int i = 0; i < fab_.size(); ++i) {
            Vertex v = fab_.vertex(i);
            add_freudenthal_simplices_from_vertex(v, d, disps);
        }
    }

    Int CohBlock::global_id(const IdxVector& global_vertex_ids, Point v, size_t deltas_idx) const
    {
        assert(n_cells_in_lower_dimension_.at(global_vertex_ids.size() - 1) + deltas_idx <= total_n_cells_per_cube_);

        Int result = global_domain_.index(v) * total_n_cells_per_cube_ + n_cells_in_lower_dimension_.at(global_vertex_ids.size() - 1) + deltas_idx;

        return result;
    }

    Vertex CohBlock::from_local_to_global(const Vertex& v)
    {
        Vertex v_global = v;
        for(unsigned k = 0; k < CADMUS_DIM; ++k) {
            v_global[k] += core.min[k];
        }
        return v_global;
    }

    Vertex CohBlock::from_global_to_local(const Vertex& v)
    {
        Vertex v_local = v;
        for(unsigned k = 0; k < CADMUS_DIM; ++k) {
            v_local[k] -= core.min[k];
        }
        return v_local;
    }

    void CohBlock::add_freudenthal_simplices_from_vertex(const Vertex& v, dim_type d, const VertexVecVec& disps)
    {
        auto logger = spd::get("console");

        // indices of simplex vector
        // index is taken in global domain
        IdxVector global_vertex_ids(d + 1, -1);

        for(size_t deltas_idx = 0; deltas_idx < disps.size(); ++deltas_idx) {
            auto& deltas = disps[deltas_idx];
            Real value = std::numeric_limits<Real>::lowest();

            assert(deltas.size() == d + 1);

            bool is_interior_simplex = false;
            bool is_valid_simplex = true;

            std::vector<diy::Point<int, CADMUS_DIM>> u_globals;

            Vertex v_global = from_local_to_global(v);

            for(size_t i = 0; i < d + 1; ++i) {
                auto u_local = v + deltas[i];

                if (not fab_.contains(u_local)) {
                    is_valid_simplex = false;
                    // simplex is not in local box, skip
                    break;
                }

                Real u_value = fab_(u_local);
                value = std::max(value, u_value);

                auto u_global = from_local_to_global(u_local);

                u_globals.push_back(u_global);

                assert(global_domain_.contains(u_global));

                global_vertex_ids[i] = global_domain_.index(u_global);

                // if at least one vertex of simplex is inside cube, the simplex is interior
                if (not is_union(u_local))
                    is_interior_simplex = true;
            }

            if (not is_valid_simplex)
                continue;

            auto simplex_id = global_id(global_vertex_ids, v_global, deltas_idx);

            simplices.emplace_back(simplex_id, global_vertex_ids, value, u_globals);

//            if (logger) logger->trace("global_vertex_ids = {},  simplex_id = {}", global_vertex_ids, simplex_id);
//            if (logger) logger->trace("added simplex: {}", simplices.back());

            // save unique id of union simplex in class member
            if (not is_interior_simplex) {
                union_uids_.insert(simplex_id);
            }
        }
    }

    std::tuple<bool, bool, Real> CohBlock::get_cube_validity_interior_and_value(Int cube_id)
    {
        Real value = -std::numeric_limits<Real>::max();

        bool is_valid {true};

        bool is_interior {false};

        for(auto&& u_global : get_cube_vertices(cube_id)) {
            Point u_local = from_global_to_local(u_global);

            if (not fab_.contains(u_local)) {
//            if (not Cube::global_domain_.contains(u_global)) {
                is_valid = false;
                break;
            }


            if (not is_union(u_local))
                    is_interior = true;

            value = std::max(fab_(u_local), value);
        }

        return {is_valid, is_interior, value};
    }

    CubicalFiltration CohBlock::get_cubical_filtration(dim_type top_d)
    {
        CALI_CXX_MARK_FUNCTION;
        auto logger = spd::get("console");
        // calculate total number of cells to allocate memory once
        size_t total_size = 0;

        for(dim_type d = 0; d <= top_d; ++d) {
            total_size += get_n_cubes_in_dimension(d) * fab_.size();
        }

        Cubes cubes;

        for(Int i = 0; i < fab_.size(); ++i) {
            Vertex v_local = fab_.vertex(i);
            Vertex v_global = from_local_to_global(v_local);
            Int v_part = global_domain_.index(v_global) << CADMUS_DIM;
            for(Int face_part = 0; face_part < (1 << CADMUS_DIM); ++face_part) {
                Int cube_id = v_part | face_part;

                auto [is_valid, is_interior, cube_value] = get_cube_validity_interior_and_value(cube_id);

                if (not is_valid)
                    continue;

                if (not is_interior)
                    union_uids_.insert(cube_id);

//                if (logger) logger->debug("GID {}, Added cube: cube_id = {:b}, v_local = {}, v_global = {}, v_part = {:b}, face_part = {:b}, is_interior = {}", stats_.gid, cube_id, v_local, v_global, v_part, face_part, is_interior);

                cubes.emplace_back(cube_id, cube_value);
            }
        }

        return CubicalFiltration (std::move(cubes));
    }

    int CohBlock::gid_by_col_value(const UidValue& col_val) const
    {
        auto lb_iter = std::lower_bound(boundaries_.begin(), boundaries_.end(), col_val.value, std::greater<>());
        return lb_iter - boundaries_.begin();
    }

    int CohBlock::gid_by_row_value(const UidValue& row_val) const
    {
        auto lb_iter = std::lower_bound(boundaries_.begin(), boundaries_.end(), row_val.value, std::greater<>());
        return lb_iter - boundaries_.begin();
    }

}


